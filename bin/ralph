#!/usr/bin/env bash

# Ralph Loop - Autonomous Claude Code runner
#
# Usage: ralph [options]
#
# Creates an autonomous loop where Claude executes tasks from a prompt file.
# Each iteration starts fresh (no context accumulation).
# Failed tasks are tracked and skipped after MAX_ATTEMPTS failures.

# shellcheck disable=SC2034  # Variables are used across sourced lib files
set -euo pipefail

# -----------------------------------------------------------------------------
# Library discovery and loading
# -----------------------------------------------------------------------------
# Resolve symlinks portably (readlink -f not available on stock macOS)
_resolve_symlink() {
  local target="$1"
  if [[ "$target" != */* ]]; then
    local resolved
    resolved="$(command -v -- "$target" 2>/dev/null || true)"
    if [[ -n "$resolved" && "$resolved" == /* ]]; then
      target="$resolved"
    fi
  fi
  while [[ -L "$target" ]]; do
    local dir
    dir="$(cd "$(dirname "$target")" && pwd)"
    target="$(readlink "$target")"
    # Handle relative symlink targets
    [[ "$target" != /* ]] && target="${dir}/${target}"
  done
  echo "$target"
}

RALPH_REAL_PATH="$(_resolve_symlink "${BASH_SOURCE[0]}")"
RALPH_SCRIPT_DIR="$(cd "$(dirname "$RALPH_REAL_PATH")" && pwd)"
RALPH_LIB_DIR="${RALPH_LIB_DIR:-${RALPH_SCRIPT_DIR}/../lib}"

if [[ ! -d "$RALPH_LIB_DIR" ]]; then
  # Fallback for system-wide install
  RALPH_LIB_DIR="/usr/local/lib/ralph"
fi

if [[ ! -d "$RALPH_LIB_DIR" ]]; then
  echo "Error: Cannot find ralph lib directory at ${RALPH_LIB_DIR}" >&2
  exit 1
fi

for lib in colors utils ui lock attempts claims workers engine iteration loop; do
  # shellcheck source=/dev/null
  . "${RALPH_LIB_DIR}/${lib}.sh"
done

setup_colors

# -----------------------------------------------------------------------------
# Defaults
# -----------------------------------------------------------------------------
PROMPT_FILE="RALPH_TASK.md"
MAX_ITERATIONS=0        # 0 = unlimited
WAIT_TIME=5
USE_CAFFEINATE=false
LOG_FILE=""
ATTEMPTS_FILE=".ralph_attempts.json"
MAX_ATTEMPTS=3          # Skip task after this many failures
ITERATION_TIMEOUT=600   # 10 minutes max per iteration
MAX_TOOL_CALLS=50       # Consider stuck if more than this without completing
QUIET=false
ENGINE="claude"
CODEX_EXEC_FLAGS="--full-auto"
SHOW_QUOTE_EACH_ITERATION=true
BELL_ON_COMPLETION=false
BELL_ON_END=false
EXIT_ON_COMPLETE=true
ENABLE_TITLE=true
SHOW_RESOURCES=true
WAIT_COUNTDOWN=true
ALLOWED_TOOLS=""
DISALLOWED_TOOLS=""
NUM_WORKERS=1
WORKER_ID=0             # 0 = main process, 1..N = worker subprocess

# Save original args for caffeinate re-exec
ORIGINAL_ARGS=("$@")

# Global run context (set in print_header)
RUN_ID=""
STARTED_AT=""
STARTED_EPOCH=0

# Run statistics (for summary on exit)
COMPLETED_COUNT=0
FAILED_COUNT=0
ITERATION_COUNT=0

# Process tracking
CLAUDE_PID=""
WORKER_PIDS=()
TAIL_PIDS=()

# -----------------------------------------------------------------------------
# CLI parsing
# -----------------------------------------------------------------------------
_require_arg() { [[ $# -ge 2 ]] || { echo "Error: Option $1 requires an argument" >&2; exit 1; }; }
_validate_path_arg() {
  local label="$1" path="$2"
  if [[ -z "$path" ]]; then
    log_err "${label} path cannot be empty"
    exit 1
  fi
  if [[ "$path" == *$'\n'* || "$path" == *$'\r'* ]]; then
    log_err "${label} path contains newline characters"
    exit 1
  fi
  if [[ "$path" == -* ]]; then
    log_err "${label} path cannot start with '-' (use ./<path> to disambiguate)"
    exit 1
  fi
}

_validate_log_file() {
  local path="$1"
  _validate_path_arg "Log file" "$path"
  if [[ -e "$path" && ! -f "$path" ]]; then
    log_err "Log path exists but is not a regular file: $path"
    exit 1
  fi
  local dir
  dir="$(dirname -- "$path")"
  if [[ ! -d "$dir" ]]; then
    log_err "Log directory does not exist: $dir"
    exit 1
  fi
  if [[ ! -w "$dir" ]]; then
    log_err "Log directory is not writable: $dir"
    exit 1
  fi
  if [[ -e "$path" && ! -w "$path" ]]; then
    log_err "Log file is not writable: $path"
    exit 1
  fi
}

while [[ $# -gt 0 ]]; do
  case $1 in
    -p|--prompt)    _require_arg "$@"; PROMPT_FILE="$2"; shift 2 ;;
    -e|--engine)    _require_arg "$@"; ENGINE="$2"; shift 2 ;;
    --codex-flags)  _require_arg "$@"; CODEX_EXEC_FLAGS="$2"; shift 2 ;;
    -m|--max)       _require_arg "$@"; MAX_ITERATIONS="$2"; shift 2 ;;
    -w|--wait)      _require_arg "$@"; WAIT_TIME="$2"; shift 2 ;;
    -a|--attempts)  _require_arg "$@"; MAX_ATTEMPTS="$2"; shift 2 ;;
    -t|--timeout)   _require_arg "$@"; ITERATION_TIMEOUT="$2"; shift 2 ;;
    --max-tools)    _require_arg "$@"; MAX_TOOL_CALLS="$2"; shift 2 ;;
    -c|--caffeinate) USE_CAFFEINATE=true; shift ;;
    -q|--quiet)     QUIET=true; shift ;;
    --no-iter-quote) SHOW_QUOTE_EACH_ITERATION=false; shift ;;
    --bell-on-completion) BELL_ON_COMPLETION=true; shift ;;
    --bell-on-end)  BELL_ON_END=true; shift ;;
    --no-exit-on-complete) EXIT_ON_COMPLETE=false; shift ;;
    --no-title)     ENABLE_TITLE=false; shift ;;
    --no-resources) SHOW_RESOURCES=false; shift ;;
    --no-wait-countdown) WAIT_COUNTDOWN=false; shift ;;
    -j|--workers) _require_arg "$@"; NUM_WORKERS="$2"; shift 2 ;;
    --allowed-tools) _require_arg "$@"; ALLOWED_TOOLS="$2"; shift 2 ;;
    --disallowed-tools) _require_arg "$@"; DISALLOWED_TOOLS="$2"; shift 2 ;;
    -l|--log)
      if [[ -n "${2:-}" && ! "$2" =~ ^- ]]; then
        LOG_FILE="$2"; shift 2
      else
        LOG_FILE="ralph_$(date '+%Y-%m-%d_%H-%M-%S').log"; shift
      fi ;;
    --clear-attempts)
      init_attempts_file
      clear_attempts
      log_ok "Cleared all attempt tracking. Tasks will be retried."
      exit 0 ;;
    --show-attempts)
      init_attempts_file
      show_attempts
      exit 0 ;;
    -h|--help) usage; exit 0 ;;
    *)
      log_err "Unknown option: $1"
      echo ""
      usage
      exit 1 ;;
  esac
done

# -----------------------------------------------------------------------------
# Validate inputs
# -----------------------------------------------------------------------------
if [[ "$ENGINE" != "claude" && "$ENGINE" != "codex" ]]; then
  log_err "Unknown engine: $ENGINE (must be 'claude' or 'codex')"
  exit 1
fi

for _numvar_name in MAX_ITERATIONS WAIT_TIME MAX_ATTEMPTS ITERATION_TIMEOUT MAX_TOOL_CALLS NUM_WORKERS; do
  _numvar_val="${!_numvar_name}"
  if ! [[ "$_numvar_val" =~ ^[0-9]+$ ]]; then
    log_err "${_numvar_name} must be a non-negative integer, got: $_numvar_val"
    exit 1
  fi
done

if [[ "$NUM_WORKERS" -lt 1 || "$NUM_WORKERS" -gt 16 ]]; then
  log_err "Workers must be 1-16, got: $NUM_WORKERS"
  exit 1
fi

_validate_path_arg "Prompt file" "$PROMPT_FILE"
if [[ -n "$LOG_FILE" ]]; then
  _validate_log_file "$LOG_FILE"
fi

# -----------------------------------------------------------------------------
# Caffeinate: re-exec under caffeinate if requested
# -----------------------------------------------------------------------------
if [[ "$USE_CAFFEINATE" == true && -z "${RALPH_CAFFEINATED:-}" ]]; then
  if ! command -v caffeinate >/dev/null 2>&1; then
    log_err "caffeinate not found (only available on macOS)"
    exit 1
  fi
  log_info "Running with caffeinate (Mac will stay awake)"
  export RALPH_CAFFEINATED=1
  filtered_args=()
  for arg in "${ORIGINAL_ARGS[@]}"; do
    [[ "$arg" != "-c" && "$arg" != "--caffeinate" ]] && filtered_args+=("$arg")
  done
  exec caffeinate -i "$RALPH_REAL_PATH" "${filtered_args[@]}"
fi

# -----------------------------------------------------------------------------
# Preflight checks
# -----------------------------------------------------------------------------
check_dependencies

if [[ ! -f "$PROMPT_FILE" ]]; then
  log_err "Prompt file '$PROMPT_FILE' not found"
  echo ""
  cat <<EOF
Create a RALPH_TASK.md with your task instructions, for example:

  # Task
  Read TODO.md and find the first unchecked item.
  Complete it, then mark it [x] done.
EOF
  exit 1
fi
if [[ ! -r "$PROMPT_FILE" ]]; then
  log_err "Prompt file '$PROMPT_FILE' is not readable"
  exit 1
fi

init_attempts_file

# -----------------------------------------------------------------------------
# Header
# -----------------------------------------------------------------------------
print_header() {
  RUN_ID="$(generate_run_id)"
  STARTED_AT="$(date '+%Y-%m-%d %H:%M:%S')"
  STARTED_EPOCH="$(date '+%s')"

  set_title "RALPH LOOP | starting..."

  printf "%b\n" "${BLUE}"
  cat << "LOGO"
   ██████╗  █████╗ ██╗     ██████╗ ██╗  ██╗
   ██╔══██╗██╔══██╗██║     ██╔══██╗██║  ██║
   ██████╔╝███████║██║     ██████╔╝███████║
   ██╔══██╗██╔══██║██║     ██╔═══╝ ██╔══██║
   ██║  ██║██║  ██║███████╗██║     ██║  ██║
   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝  ╚═╝

        R A L P H   L O O P
LOGO
  printf "%b\n" "${NC}"

  hr
  local engine_label
  engine_label="$(printf "%s" "$ENGINE" | tr '[:lower:]' '[:upper:]')"
  printf "%b\n" "${BOLD}${BLUE}Autonomous Agent Runner${NC} ${DIM}(${engine_label} | fresh context each iteration)${NC}"
  printf "%b\n" "${DIM}Run ID:${NC} ${BOLD}${CYAN}${RUN_ID}${NC}  ${DIM}Started:${NC} ${CYAN}${STARTED_AT}${NC}"
  hr
  echo ""
}

print_header

# -----------------------------------------------------------------------------
# Config panel
# -----------------------------------------------------------------------------
box_title "Config"

max_iter_display="$([[ $MAX_ITERATIONS -eq 0 ]] && echo "unlimited" || echo "${MAX_ITERATIONS}")"
timeout_display="$(fmt_hms "$ITERATION_TIMEOUT")"
wait_display="$(fmt_hms "$WAIT_TIME")"

skipped_list="$(get_skipped_tasks || true)"
skipped_count=0
if [[ -n "$skipped_list" ]]; then
  skipped_count="$(printf "%s\n" "$skipped_list" | wc -l | tr -d ' ')"
fi

engine_display="$(printf "%s" "$ENGINE" | tr '[:lower:]' '[:upper:]')"
if [[ "$ENGINE" == "codex" ]]; then
  engine_display="${engine_display} (flags: ${CODEX_EXEC_FLAGS})"
fi

if [[ "$NUM_WORKERS" -gt 1 ]]; then
  printf "  %-16s %b\n" "Workers:" "${YELLOW}${NUM_WORKERS} parallel${NC}"
else
  printf "  %-16s %b\n" "Workers:" "${DIM}1 (sequential)${NC}"
fi
printf "  %-16s %b\n" "Engine:"     "${CYAN}${engine_display}${NC}"
printf "  %-16s %b\n" "Prompt:"     "${GREEN}${PROMPT_FILE}${NC}"
printf "  %-16s %b\n" "Iterations:" "${YELLOW}${max_iter_display}${NC}"
printf "  %-16s %b\n" "Wait:"       "${YELLOW}${wait_display}${NC}"
printf "  %-16s %b\n" "Attempts:"   "${YELLOW}${MAX_ATTEMPTS}${NC}"
printf "  %-16s %b\n" "Timeout:"    "${YELLOW}${timeout_display}${NC}"
printf "  %-16s %b\n" "Max tools:"  "${YELLOW}${MAX_TOOL_CALLS}${NC}"
printf "  %-16s %b\n" "Exit on done:"  "$([[ "$EXIT_ON_COMPLETE" == "true" ]] && echo "${GREEN}yes${NC}" || echo "${YELLOW}no (loop forever)${NC}")"

if [[ -n "$LOG_FILE" ]]; then
  printf "  %-16s %b\n" "Log:"        "${GREEN}${LOG_FILE}${NC}"
else
  printf "  %-16s %b\n" "Log:"        "${DIM}(disabled)${NC}"
fi

if [[ "$skipped_count" -gt 0 ]]; then
  printf "  %-16s %b\n" "Skipped:"    "${RED}${skipped_count}${NC} ${DIM}(use --show-attempts)${NC}"
else
  printf "  %-16s %b\n" "Skipped:"    "${GREEN}0${NC}"
fi

echo ""
log_dim "Tip: Ctrl+C stops | --quiet for minimal output | --no-title if your terminal hates OSC"
echo ""

if [[ "$QUIET" == "false" ]]; then
  sleep 1
fi

# -----------------------------------------------------------------------------
# Signal handling
# -----------------------------------------------------------------------------
cleanup() {
  echo ""
  log_warn "Caught interrupt signal, shutting down..."
  set_title "RALPH LOOP | stopping..."

  if [[ "$NUM_WORKERS" -gt 1 ]]; then
    # Signal workers to stop via sentinel
    signal_exit
    # Kill tail processes
    for pid in "${TAIL_PIDS[@]}"; do
      kill "$pid" 2>/dev/null || true
    done
    # Kill worker processes and their children
    for pid in "${WORKER_PIDS[@]}"; do
      pkill -P "$pid" 2>/dev/null || true
      kill "$pid" 2>/dev/null || true
    done
    # BUG FIX #6: Wait for workers to actually terminate instead of arbitrary sleep
    for pid in "${WORKER_PIDS[@]}"; do
      local wait_count=0
      while kill -0 "$pid" 2>/dev/null && [[ "$wait_count" -lt 50 ]]; do
        sleep 0.1
        wait_count=$((wait_count + 1))
      done
    done
    # Aggregate counters from all workers
    if [[ -n "${WORKER_STATE_DIR:-}" && -d "${WORKER_STATE_DIR:-}" ]]; then
      local totals
      totals="$(read_all_counters)"
      COMPLETED_COUNT="$(echo "$totals" | awk '{print $1}')"
      FAILED_COUNT="$(echo "$totals" | awk '{print $2}')"
      ITERATION_COUNT="$(echo "$totals" | awk '{print $3}')"
    fi
  else
    if [[ -n "${CLAUDE_PID:-}" ]]; then
      kill "$CLAUDE_PID" 2>/dev/null || true
    fi
  fi

  pkill -P $$ 2>/dev/null || true
  show_run_summary
  bell end

  # Cleanup worker state dir
  [[ -n "${WORKER_STATE_DIR:-}" && -d "${WORKER_STATE_DIR:-}" ]] && rm -rf "$WORKER_STATE_DIR" 2>/dev/null || true

  exit 0
}
trap cleanup INT TERM
trap 'reapply_scroll_region' WINCH

# -----------------------------------------------------------------------------
# Run
# -----------------------------------------------------------------------------
if [[ "$NUM_WORKERS" -gt 1 ]]; then
  run_parallel "$PROMPT_FILE"
else
  run_loop "$PROMPT_FILE"
fi
